#!/usr/bin/env python
"""py-web-tool Literate Programming.

Yet another simple literate programming tool derived from **nuweb**, 
implemented entirely in Python.
With a suitable configuration, this weaves documents with any markup language,
and tangles source files for any programming language.
"""
__version__ = """3.2"""

### DO NOT EDIT THIS FILE!
### It was created by pyweb.py, __version__='3.2'.
### From source impl.w modified Mon Jul  4 15:36:20 2022.
### In working directory '/Users/slott/Documents/Projects/py-web-tool/src'.

from collections import defaultdict
from collections.abc import Iterator
from dataclasses import dataclass, field
from functools import cache
import logging
from pathlib import Path
from types import SimpleNamespace
from typing import Any, Optional, Literal, ClassVar, Union
from weakref import ref, ReferenceType
from typing import TypeGuard, TypeVar, Generic
import abc
from textwrap import dedent
from jinja2 import Environment, DictLoader, select_autoescape
import filecmp
import tempfile
import os
import builtins
import sys
import platform

from typing import TextIO, cast
import re
from collections.abc import Iterator, Iterable

import shlex

import argparse

import logging
import logging.config

import os
import time
import datetime
import types



class Error(Exception): pass



_T = TypeVar("_T")

class TypeId:
    """
    This makes a given class name into an attribute with a 
    True value. Any other attribute reference will return False.
    
    >>> class A:
    ...     typeid = TypeId()
    >>> a = A()
    >>> a.typeid.A 
    True
    >>> a.typeid.B
    False
    """             
    def __set_name__(self, owner: type[_T], name: str) -> "TypeId":
        self.my_class = owner
        return self

    def __getattr__(self, item: str) -> TypeGuard[_T]:
        return self.my_class.__name__ == item
        
from collections.abc import Mapping

class TypeIdMeta(type):
    """Inject the ``typeid`` attribute into a class definition."""
    @classmethod
    def __prepare__(metacls, name: str, bases: tuple[type, ...], **kwds: Any) -> Mapping[str, object]:  # type: ignore[override]
        return {"typeid": TypeId()}


class Command(metaclass=TypeIdMeta):
    typeid: TypeId
    has_name: TypeGuard["ReferenceCommand"] = False
    has_text: TypeGuard[Union["CodeCommand", "TextCommand"]] = False
        
    def __init__(self, location: tuple[str, int]) -> None:
        self.location = location  #: The (filename, line number)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.web: ReferenceType["Web"]
        
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(location={self.location!r})"
        
    @abc.abstractmethod
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        ...


class TextCommand(Command):
    """Text outside any other command."""    
    has_text: TypeGuard[Union["CodeCommand", "TextCommand"]] = True
    
    def __init__(self, text: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.text = text  #: The text
            
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        self.logger.debug(f"tangle {self.text=!r}")
        aTangler.codeBlock(target, self.text)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(text={self.text!r}, location={self.location!r})"

class CodeCommand(Command):
    """Code inside a ``@o``, or ``@d`` command."""    
    has_text: TypeGuard[Union["CodeCommand", "TextCommand"]] = True

    def __init__(self, text: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.text = text  #: The text

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        self.logger.debug(f"tangle {self.text=!r}")
        aTangler.codeBlock(target, self.text)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(text={self.text!r}, location={self.location!r})"

class ReferenceCommand(Command):
    """
    Reference to a ``NamedChunk`` in code, a ``@< name @>`` construct.
    In a CodeChunk or OutputChunk, it tangles to the definition from a ``NamedChunk``.
    In text, it can weave to the text of a ``NamedDocumentChunk``.
    """    
    has_name: TypeGuard["ReferenceCommand"] = True

    def __init__(self, name: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.name = name  #: The name that is referenced.
    
    @property
    def full_name(self) -> str:
        return cast(Web, self.web()).resolve_name(self.name)

    @property
    def seq(self) -> int | None:
        return cast(Web, self.web()).resolve_chunk(self.name)[0].seq

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        """Expand this reference.
        The starting position is the indentation for all **subsequent** lines.
        Provide the indent before ``@<``, in ``tangler.fragment`` back to the tangler. 
        """
        self.logger.debug(f"tangle reference to {self.name=}, context: {aTangler.fragment=}")
        chunk_list = cast(Web, self.web()).resolve_chunk(self.name)
        if len(chunk_list) == 0:
            message = f"Attempt to tangle an undefined Chunk, {self.name!r}"
            self.logger.error(message)
            raise Error(message) 
        aTangler.reference_names.add(self.name)
        aTangler.addIndent(len(aTangler.fragment))
        aTangler.fragment = ""

        for chunk in chunk_list:
            # TODO: if chunk.options includes '-indent': do an setIndent before tangling.
            for command in chunk.commands:
                command.tangle(aTangler, target)
                
        aTangler.clrIndent()

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name={self.name!r}, location={self.location!r})"

class FileXrefCommand(Command):
    """The ``@f`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def files(self) -> list["OutputChunk"]:
        return cast(Web, self.web()).files

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')

class MacroXrefCommand(Command):
    """The ``@m`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def macros(self) -> list[SimpleNamespace]:
        return cast(Web, self.web()).macros

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')

class UserIdXrefCommand(Command):
    """The ``@u`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def userids(self) -> list[SimpleNamespace]:
        return cast(Web, self.web()).userids
        
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')
        
HasText = Union["CodeCommand", "TextCommand"]



@dataclass
class Chunk:
    """Superclass for OutputChunk, NamedChunk, NamedDocumentChunk.

    Chunk is the anonymous text context. 
        The Text, Ref, and the various XREF commands can *only* appear here.
        A REF must be do a ``@d name @[...@]`` NamedDocumentChunk, which is expanded, not linked.

    OutputChunk is the ``@o`` context. 
        The Code and Ref commands appear here.
        This is tangled to a file.

    NamedChunk is the ``@d`` context. 
        The Code and Ref commands appear here.
        This is tangled where referenced.
    """
    name: str | None = None  #: Short name of the chunk
    seq: int | None = None  #: Unique sequence number of chunk in the WEB
    commands: list["Command"] = field(default_factory=list)  #: Sequence of commands inside this chunk
    options: list[str] = field(default_factory=list)  #: Parsed options for @d and @o chunks.
    def_names: list[str] = field(default_factory=list)  #: Names defined after ``@|`` in this chunk
    initial: bool = False  #: Is this the first use of a given Chunk name?
    comment_start: str | None = None  #: If injecting location details, this is the prefix
    comment_end: str | None = None  #: If injecting location details, this is the suffix

    references: int = field(init=False, default=0)
    referencedBy: Optional["Chunk"] = field(init=False, default=None)
    web: ReferenceType["Web"] = field(init=False, repr=False)
    logger: logging.Logger = field(init=False, default=logging.getLogger("Chunk"))

    @property
    def full_name(self) -> str | None:
        if self.name:
            return cast(Web, self.web()).resolve_name(self.name)
        else:
            return None

    @property
    def path(self) -> Path | None:
        return None

    @property
    def location(self) -> tuple[str, int]:
        return self.commands[0].location

    def type_is(self, name: str) -> bool:
        """There are really two interesting features:
        - has_code() (i.e., NamedChunk and OutputChunk)
        - has_text() (i.e., Chunk and NamedDocumentChunk)
        """
        return self.__class__.__name__ == name

class OutputChunk(Chunk):
    @property
    def path(self) -> Path | None:
        if self.name:
            return Path(self.name)
        else:
            return None

    @property
    def full_name(self) -> str | None:
        return None

class NamedChunk(Chunk): 
    pass

class NamedChunk_Noindent(Chunk): 
    pass

class NamedDocumentChunk(Chunk): 
    pass





@dataclass
class Web:
    chunks: list["Chunk"]  #: The source sequence of chunks.

    # The ``@d`` chunk names and locations where they're defined.
    chunk_map: dict[str, list["Chunk"]] = field(init=False)
    
    # The ``@|`` defined names and chunks with which they're associated.
    userid_map: defaultdict[str, list["Chunk"]] = field(init=False)
    
    references: set[str] = field(init=False, default_factory=set)
    
    logger: logging.Logger = field(init=False, default=logging.getLogger("Web"))

    strict_match: ClassVar[bool] = True  #: Don't permit ... names without a definition.
    
    web_path: Path = field(init=False)  #: Source WEB file; set by ```WebParse``
    
    def __post_init__(self) -> None:
        """
        Populate weak references throughout the web to make full_name properties work.
        Then. Locate all macro definitions and userid references. 
        """
        # Pass 1 -- set all Chunk and Command back references.
        for c in self.chunks:
            c.web = ref(self)
            for cmd in c.commands:
                cmd.web = ref(self)
                
        # Named Chunks = Union of macro_iter and file_iter
        named_chunks = list(filter(lambda c: c.name is not None, self.chunks))

        # Pass 2 -- locate the unabbreviated names in chunks and references to chunks
        self.chunk_map = {}
        for seq, c in enumerate(named_chunks, start=1):
            c.seq = seq
            if not c.path:
                # Use ``@d name`` chunks (reject ``@o`` and text)
                if c.name and not c.name.endswith('...'):
                    self.logger.debug(f"__post_init__ 2a {c.name=!r}")
                    self.chunk_map.setdefault(c.name, [])
            for cmd in c.commands:
                # Find ``@< name @>`` in ``@d name`` chunks or ``@o`` chunks 
                if cmd.has_name:
                    if not cast(ReferenceCommand, cmd).name.endswith('...'):
                        self.logger.debug(f"__post_init__ 2b {cast(ReferenceCommand, cmd).name=!r}")
                        self.chunk_map.setdefault(cast(ReferenceCommand, cmd).name, [])
                    
        # Pass 3 -- accumulate chunk lists, output lists, and name definition lists
        self.userid_map = defaultdict(list)
        for c in named_chunks:
            for name in c.def_names:
                self.userid_map[name].append(c)
            if not c.path:
                # Named ``@d name`` chunks
                if full_name := c.full_name:
                    c.initial = len(self.chunk_map[full_name]) == 0
                    self.chunk_map[full_name].append(c)
                    self.logger.debug(f"__post_init__ 3 {c.name=!r} -> {c.full_name=!r}")
            else:
                # Output ``@o`` and anonymous chunks.
                # Assume all @o chunks are unique. If they're not, they overwrite each other.
                # Also, there's not ``full_name`` for these chunks.
                c.initial = True
                
            # TODO: Accumulate all chunks that contribute to a named file...

        # Pass 4 -- set referencedBy a command in a chunk.
        # NOTE: Assuming single references *only*
        # We should raise an exception when updating a non-None referencedBy value.
        # Or incrementing ref_chunk.references > 1.
        for c in named_chunks:
            for cmd in c.commands:
                if cmd.has_name:
                    ref_to_list = self.resolve_chunk(cast(ReferenceCommand, cmd).name)
                    for ref_chunk in ref_to_list:
                        ref_chunk.referencedBy = c
                        ref_chunk.references += 1
            
    def __repr__(self) -> str:
        NL = ",\n"
        return (
            f"{self.__class__.__name__}("
            f"{NL.join(repr(c) for c in self.chunks)}"
            f")"
        )
        
    def resolve_name(self, target: str) -> str:
        """Map short names to full names, if possible."""
        if target in self.chunk_map:
            # self.logger.debug(f"resolve_name {target=} in self.chunk_map")
            return target
        elif target.endswith('...'):
            # The ... is equivalent to regular expression .*
            matches = list(
                c_name
                for c_name in self.chunk_map
                if c_name.startswith(target[:-3])
            )
            match : str
            # self.logger.debug(f"resolve_name {target=} {matches=} in self.chunk_map")
            match matches:
                case []:
                    if self.strict_match:
                        raise Error(f"No full name for {target!r}")
                    else:
                        self.logger.warning(f"resolve_name {target=} unknown")
                        self.chunk_map[target] = []
                    match = target
                case [head]:
                    match = head
                case [head, *tail]:
                    message = f"Ambiguous abbreviation {target!r}, matches {[head] + tail!r}"
                    raise Error(message)
            return match
        else:
            self.logger.warning(f"resolve_name {target=} unknown")
            self.chunk_map[target] = []
            return target

    def resolve_chunk(self, target: str) -> list["Chunk"]:
        """Map name (short or full) to the defining sequence of chunks."""
        full_name = self.resolve_name(target)
        chunk_list = self.chunk_map[full_name]
        self.logger.debug(f"resolve_chunk {target=!r} -> {full_name=!r} -> {chunk_list=}")
        return chunk_list

    def file_iter(self) -> Iterator[OutputChunk]:
        return (cast(OutputChunk, c) for c in self.chunks if c.type_is("OutputChunk"))

    def macro_iter(self) -> Iterator[NamedChunk]:
        return (cast(NamedChunk, c) for c in self.chunks if c.type_is("NamedChunk"))

    def userid_iter(self) -> Iterator[SimpleNamespace]:
        yield from (SimpleNamespace(def_name=n, chunk=c) for c in self.file_iter() for n in c.def_names)
        yield from (SimpleNamespace(def_name=n, chunk=c) for c in self.macro_iter() for n in c.def_names)

    @property
    def files(self) -> list["OutputChunk"]:
        return list(self.file_iter())

    @property
    def macros(self) -> list[SimpleNamespace]:
        """
        The chunk_map has the list of Chunks that comprise a macro definition.
        We separate those to make it slightly easier to format the first definition.
        """
        first_list = (
            (self.chunk_map[name][0], self.chunk_map[name])
            for name in sorted(self.chunk_map)
            if self.chunk_map[name]
        )
        macro_list = list(
            SimpleNamespace(name=first_def.name, full_name=first_def.full_name, seq=first_def.seq, def_list=def_list)
            for first_def, def_list in first_list
        )
        # self.logger.debug(f"macros: {defs}")
        return macro_list

    @property
    def userids(self) -> list[SimpleNamespace]:
        userid_list = list(
            SimpleNamespace(userid=userid, ref_list=self.userid_map[userid])
            for userid in sorted(self.userid_map)
        )
        # self.logger.debug(f"userids: {userid_list}")
        return userid_list
            
    def no_reference(self) -> list[Chunk]:
        return list(filter(lambda c: c.name and not c.path and c.references == 0, self.chunks))
        
    def multi_reference(self) -> list[Chunk]:
        return list(filter(lambda c: c.name and not c.path and c.references > 1, self.chunks))
        
    # def no_definition(self) -> list[Command]:
    #    commands = (
    #        cmd for c in self.chunks for cmd in c.commands
    #    )
    #    return list(filter(lambda cmd: not cmd.definition, commands))




class Reference(abc.ABC):
    def __init__(self) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)
        
    @abc.abstractmethod
    def chunkReferencedBy(self, aChunk: Chunk) -> list[Chunk]:
        """Return a list of Chunks."""
        ...

class SimpleReference(Reference):
    def chunkReferencedBy(self, aChunk: Chunk) -> list[Chunk]:
        if aChunk.referencedBy:
            return [aChunk.referencedBy]
        return []

class TransitiveReference(Reference):
    def chunkReferencedBy(self, aChunk: Chunk) -> list[Chunk]:
        refBy = aChunk.referencedBy
        if refBy:
            all_refs = list(self.allParentsOf(refBy))
            self.logger.debug("References: %r(%d) %r", aChunk.name, aChunk.seq, all_refs)
            return all_refs
        else:
            return []
        
    @staticmethod
    def allParentsOf(chunk: Chunk | None, depth: int = 0) -> Iterator[Chunk]:
        """Transitive closure of parents via recursive ascent.
        """
        if chunk:
            yield chunk
            yield from TransitiveReference.allParentsOf(chunk.referencedBy, depth+1)
 


class Emitter(abc.ABC):
    def __init__(self, output: Path): 
        self.logger = logging.getLogger(self.__class__.__qualname__)
        self.log_indent = logging.getLogger("indent." + self.__class__.__qualname__)
        self.output = output
    
    @abc.abstractmethod
    def emit(self, web: Web) -> None:
        pass



def rst_quote_rules(text: str) -> str:
    quoted_chars = [
        ('\\', r'\\'), # Must be first.
        ('`', r'\`'),
        ('_', r'\_'), 
        ('*', r'\*'),
        ('|', r'\|'),
    ]
    clean = text
    for from_, to_ in quoted_chars:
        clean = clean.replace(from_, to_)
    return clean

def html_quote_rules(text: str) -> str:
    quoted_chars = [
        ("&", "&amp;"),  # Must be first
        ("<", "&lt;"),
        (">", "&gt;"),
        ('"', "&quot;"),  # Only applies inside tags...
    ]
    clean = text
    for from_, to_ in quoted_chars:
        clean = clean.replace(from_, to_)
    return clean

def latex_quote_rules(text: str) -> str:
    quoted_strings = [
        ("\\end{Verbatim}", "\\end\\,{Verbatim}"),  # Allow \end{Verbatim} in a Verbatim context
        ("\\{", "\\\\,{"), # Prevent unexpected commands in Verbatim
        ("$", "\\$"), # Prevent unexpected math in Verbatim
    ]
    clean = text
    for from_, to_ in quoted_strings:
        clean = clean.replace(from_, to_)
    return clean

def debug_quote_rules(text: str) -> str:
    return repr(text)
 



debug_weaver_template = dedent("""\
    {%- macro text(command) -%}
    text: {{command}}
    {%- endmacro -%}
    
    {%- macro begin_code(chunk) %}
    begin_code: {{chunk}}
    {%- endmacro -%}
    
    {%- macro code(command) %}
    code: {{command}}
    {%- endmacro -%}
    
    {%- macro ref(id) %}
    ref: {{id}}
    {%- endmacro -%}
    
    {%- macro end_code(chunk) %}
    end_code: {{chunk}}
    {% endmacro -%}
    
    {%- macro file_xref(command) -%}
    file_xref {{command.files}}
    {%- endmacro -%}
    
    {%- macro macro_xref(command) -%}
    macro_xref {{command.macros}}
    {%- endmacro -%}

    {%- macro userid_xref(command) -%}
    userid_xref {{command.userids}}
    {%- endmacro -%}
    """)



rst_weaver_template = dedent("""
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}
    
    {%- macro begin_code(chunk) %}
    ..  _`{{chunk.full_name or chunk.name}} ({{chunk.seq}})`:
    ..  rubric:: {{chunk.full_name or chunk.name}} ({{chunk.seq}}) {% if chunk.initial %}={% else %}+={% endif %}
    ..  parsed-literal::
        :class: code
        
    {% endmacro -%}

    {# For RST, each line must be indented. #}    
    {%- macro code(command) %}{% for line in command.text.splitlines() %}    {{line | quote_rules}}
    {% endfor -%}{% endmacro -%}
    
    {%- macro ref(id) %}    \N{RIGHTWARDS ARROW}\ `{{id.full_name}} ({{id.seq}})`_{% endmacro -%}
    
    {%- macro end_code(chunk) %}
    ..
    
    ..  class:: small
    
        \N{END OF PROOF} *{{chunk.full_name or chunk.name}} ({{chunk.seq}})*
        
    {% endmacro -%}
    
    {%- macro file_xref(command) -%}
    {% for file in command.files -%}
    :{{file.name}}:
        \N{RIGHTWARDS ARROW}\ `{{file.name}} ({{file.seq}})`_
    {%- endfor %}
    {%- endmacro -%}
    
    {%- macro macro_xref(command) -%}
    {% for macro in command.macros -%}
    :{{macro.full_name}}:
        {% for d in macro.def_list -%}\N{RIGHTWARDS ARROW}\ `{{d.full_name or d.name}} ({{d.seq}})`_{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
        
    {% endfor %}
    {%- endmacro -%}

    {%- macro userid_xref(command) -%}
    {% for userid in command.userids -%}
    :{{userid.userid}}:
        {% for r in userid.ref_list -%}\N{RIGHTWARDS ARROW}\ `{{r.full_name or r.name}} ({{r.seq}})`_{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
        
    {% endfor %}
    {%- endmacro -%}
    """)

rst_overrides_template = dedent("""\
    """)



html_weaver_template = dedent("""\
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}
    
    {%- macro begin_code(chunk) %}
    <a name="pyweb_{{chunk.seq}}"></a>
    <!--line number {{chunk.location}}-->
    <p><em>{{chunk.full_name or chunk.name}} ({{chunk.seq}})</em> {% if chunk.initial %}={% else %}+={% endif %}</p>
    <pre><code>
    {%- endmacro -%}
    
    {%- macro code(command) -%}{{command.text | quote_rules}}{%- endmacro -%}
    
    {%- macro ref(id) %}&rarr;<a href="#pyweb_{{id.seq}}"><em>{{id.full_name}} ({{id.seq}})</em></a>{% endmacro -%}
    
    {%- macro end_code(chunk) %}
    </code></pre>
    <p>&#8718; <em>{{chunk.full_name or chunk.name}} ({{chunk.seq}})</em>.
    </p> 
    {% endmacro -%}
    
    {%- macro file_xref(command) %}
    <dl>
    {% for file in command.files -%}
      <dt>{{file.name}}</dt><dd>{{ref(file)}}</dd>
    {%- endfor %}
    </dl>
    {% endmacro -%}
    
    {%- macro macro_xref(command) %}
    <dl>
    {% for macro in command.macros -%}
      <dt>{{macro.full_name}}<dt>
      <dd>{% for d in macro.def_list -%}{{ref(d)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}</dd>
    {% endfor %}
    </dl>
    {% endmacro -%}

    {%- macro userid_xref(command) %}
    <dl>
    {% for userid in command.userids -%}
      <dt>{{userid.userid}}</dt>
      <dd>{% for r in userid.ref_list -%}{{ref(r)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}</dd>
    {% endfor %}
    </dl>
    {% endmacro -%}
    """)

html_overrides_template = dedent("""\
    """)
 


latex_weaver_template = dedent("""\
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}
    
    {%- macro begin_code(chunk) %}
    \\label{pyweb-{{chunk.seq}}}
    \\begin{flushleft}
    \\textit{Code example {{chunk.full_name or chunk.name}} ({{chunk.seq}})}
    \\begin{Verbatim}[commandchars=\\\\\\{\\},codes={\\catcode`$$=3\\catcode`^=7},frame=single]
    {%- endmacro -%}
    
    {%- macro code(command) -%}{{command.text | quote_rules}}{%- endmacro -%}
    
    {%- macro ref(id) %}$$\\rightarrow$$ Code Example {{id.full_name}} ({{id.seq}}){% endmacro -%}
    
    {%- macro end_code(chunk) %}
    \\end{Verbatim}
    \\end{flushleft}
    {% endmacro -%}
    
    {%- macro file_xref(command) %}
    \\begin{itemize}
    {% for file in command.files -%}
      \\item {{file.name}}: {{ref(file)}}
    {%- endfor %}
    \\end{itemize}
    {% endmacro -%}
    
    {%- macro macro_xref(command) %}
    \\begin{itemize}
    {% for macro in command.macros -%}
      \\item {{macro.full_name}} \\\\
            {% for d in macro.def_list -%}{{ref(d)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
    {% endfor %}
    \\end{itemize}
    {% endmacro -%}

    {%- macro userid_xref(command) %}
    \\begin{itemize}
    {% for userid in command.userids -%}
      \\item {{userid.userid}} \\\\
            {% for r in userid.ref_list -%}{{ref(r)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
    {% endfor %}
    \\end{itemize}
    {% endmacro -%}
    """)

tex_overrides_template = dedent("""\
    """)

 


base_template = dedent("""\
    {%- from macros import text, begin_code, code, ref, end_code, file_xref, macro_xref, userid_xref -%}
    {%- if not text is defined %}{%- from defaults import text -%}{%- endif -%}
    {%- if not begin_code is defined %}{%- from defaults import begin_code -%}{%- endif -%}
    {%- if not code is defined %}{%- from defaults import code -%}{%- endif -%}
    {%- if not ref is defined %}{%- from defaults import ref -%}{%- endif -%}
    {%- if not end_code is defined %}{%- from defaults import end_code -%}{%- endif -%}
    {%- if not file_xref is defined %}{%- from defaults import file_xref -%}{%- endif -%}
    {%- if not macro_xref is defined %}{%- from defaults import macro_xref -%}{%- endif -%}
    {%- if not userid_xref is defined %}{%- from defaults import userid_xref -%}{%- endif -%}
    {% for chunk in web.chunks -%}
        {%- if chunk.type_is('OutputChunk') or chunk.type_is('NamedChunk') -%}
            {{begin_code(chunk)}}
            {%- for command in chunk.commands -%}
                {%- if command.typeid.CodeCommand -%}{{code(command)}}
                {%- elif command.typeid.ReferenceCommand -%}{{ref(command)}}
                {%- endif -%}
            {%- endfor -%}
            {{end_code(chunk)}}
        {%- elif chunk.type_is('Chunk') -%}
            {%- for command in chunk.commands -%}
                {%- if command.typeid.TextCommand %}{{text(command)}}
                {%- elif command.typeid.ReferenceCommand %}{{ref(command)}}
                {%- elif command.typeid.FileXrefCommand %}{{file_xref(command)}}
                {%- elif command.typeid.MacroXrefCommand %}{{macro_xref(command)}}
                {%- elif command.typeid.UserIdXrefCommand %}{{userid_xref(command)}}
                {%- endif -%}
            {%- endfor -%}
        {%- endif -%}
    {%- endfor %}
""")


class Weaver(Emitter):
    template_map = {
        "debug_defaults": debug_weaver_template, "debug_macros": "",
        "rst_defaults": rst_weaver_template, "rst_macros": rst_overrides_template,
        "html_defaults": html_weaver_template, "html_macros": html_overrides_template,
        "tex_defaults": latex_weaver_template, "tex_macros": tex_overrides_template,
    }
        
    quote_rules = {
        "rst": rst_quote_rules,
        "html": html_quote_rules,
        "tex": latex_quote_rules,
        "debug": debug_quote_rules,
    }

    def __init__(self, output: Path = Path.cwd()) -> None:
        super().__init__(output)
        # Summary
        self.linesWritten = 0
        
    def set_markup(self, markup: str = "rst") -> "Weaver":
        self.markup = markup
        return self
        
    def emit(self, web: Web) -> None:
        self.target_path = (self.output / web.web_path.name).with_suffix(f".{self.markup}")
        self.logger.info("Weaving %s using %s markup", self.target_path, self.markup)
        with self.target_path.open('w') as target_file:
            for text in self.generate_text(web):
                self.linesWritten += text.count("\n")
                target_file.write(text)
                
    def generate_text(self, web: Web) -> Iterator[str]:
        self.env = Environment(
            loader=DictLoader(
                self.template_map | 
                {'base_weaver': base_template,}
            ),
            autoescape=select_autoescape()
        )
        self.env.filters |= {
            "quote_rules": self.quote_rules[self.markup]
        }
        defaults = self.env.get_template(f"{self.markup}_defaults")
        macros = self.env.get_template(f"{self.markup}_macros")
        template = self.env.get_template("base_weaver")
        return template.generate(web=web, macros=macros, defaults=defaults)



class Tangler(Emitter):
    code_indent = 0  #: Initial indent

    def __init__(self, output: Path = Path.cwd()) -> None:
        super().__init__(output)
        self.context: list[int] = []
        self.resetIndent(self.code_indent)  # Create context and initial lastIndent values
        self.fragment = ""  # Nothing written yet.
        # Summary
        self.reference_names: set[str] = set()
        self.linesWritten = 0
        self.totalFiles = 0
        self.totalLines = 0

    def emit(self, web: Web) -> None:
        for file_chunk in web.files:
            self.logger.info("Tangling %s", file_chunk.name)
            self.emit_file(web, file_chunk)
            
    def emit_file(self, web: Web, file_chunk: Chunk) -> None:
        target_path = self.output / (file_chunk.name or "Untitled.out")
        self.logger.debug("Writing %s", target_path)
        self.logger.debug("Chunk %r", file_chunk)
        with target_path.open("w") as target:
            # An initial command to provide indentations.
            for command in file_chunk.commands:
                command.tangle(self, target)
                
        
    def codeBlock(self, target: TextIO, text: str) -> None:
        """Indented write of text in a ``CodeCommand``. 
        Counts lines and saves position to indent to when expanding ``@<...@>`` references.
        
        The ``fragment`` is the prevailing indent used in reference expansion.
        """
        for line in text.splitlines(keepends=True):
            self.logger.debug("codeBlock(%r)", line)
            indent = self.context[-1]
            if len(line) == 0:
                # Degenerate case of empty CodeText command. Should not occur.
                pass
            elif not line.endswith('\n'):
                # Possible start of indentation prior to a ``@<name@>``
                target.write(indent*' ')
                wrote = target.write(line)
                self.fragment = ' ' * wrote
                # May be used by a ``ReferenceCommand``, if needed.
            elif line.endswith('\n'):
                target.write(indent*' ')
                target.write(line)
                self.linesWritten += 1
            else:
                raise RuntimeError("Non-exhaustive if statement.")
    
    


        
    def addIndent(self, increment: int) -> None:
        self.lastIndent = self.context[-1]+increment
        self.context.append(self.lastIndent)
        self.log_indent.debug("addIndent %d: %r", increment, self.context)
        self.fragment = ""
        
    def setIndent(self, indent: int) -> None:
        self.context.append(indent)
        self.lastIndent = self.context[-1]
        self.log_indent.debug("setIndent %d: %r", indent, self.context)
        self.fragment = ""
    
    def clrIndent(self) -> None:
        if len(self.context) > 1:
            self.context.pop()
        self.lastIndent = self.context[-1]
        self.log_indent.debug("clrIndent %r", self.context)
        self.fragment = ""
    
    def resetIndent(self, indent: int = 0) -> None:
        """Resets the indentation context."""
        self.lastIndent = indent
        self.context = [self.lastIndent]
        self.log_indent.debug("resetIndent %d: %r", indent, self.context)
    

 


class TanglerMake(Tangler):
    def emit_file(self, web: Web, file_chunk: Chunk) -> None:
        target_path = self.output / (file_chunk.name or "Untitled.out")
        self.logger.debug("Writing %s via a temp file", target_path)
        self.logger.debug("Chunk %r", file_chunk)

        fd, tempname = tempfile.mkstemp(dir=os.curdir)
        with os.fdopen(fd, "w") as target:
            for command in file_chunk.commands:
                command.tangle(self, target)
                
        try:
            same = filecmp.cmp(tempname, target_path)
        except OSError as e:
            same = False  # Doesn't exist. (Could check for errno.ENOENT)
            
        if same:
            self.logger.info("Unchanged '%s'", target_path)
            os.remove(tempname)
        else:
            # Windows requires the original file name be removed first.
            try: 
                target_path.unlink()
            except OSError as e:
                pass  # Doesn't exist. (Could check for errno.ENOENT)
            target_path.parent.mkdir(parents=True, exist_ok=True)
            target_path.hardlink_to(tempname)
            os.remove(tempname)
            self.logger.info("Wrote %d lines to %s", self.linesWritten, target_path)



class Tokenizer(Iterator[str]):
    def __init__(self, stream: TextIO, command_char: str='@') -> None:
        self.command = command_char
        self.parsePat = re.compile(f'({self.command}.|\\n)')
        self.token_iter = (t for t in self.parsePat.split(stream.read()) if len(t) != 0)
        self.lineNumber = 0
        
    def __next__(self) -> str:
        token = next(self.token_iter)
        self.lineNumber += token.count('\n')
        return token
        
    def __iter__(self) -> Iterator[str]:
        return self




class ParseError(Exception): pass

class OptionDef:
    def __init__(self, name: str, **kw: Any) -> None:
        self.name = name
        self.__dict__.update(kw)

class OptionParser:
    def __init__(self, *arg_defs: Any) -> None:
        self.args = dict((arg.name, arg) for arg in arg_defs)
        self.trailers = [k for k in self.args.keys() if not k.startswith('-')]
        
    def parse(self, text: str) -> dict[str, list[str]]:
        try:
            word_iter = iter(shlex.split(text))
        except ValueError as e:
            raise Error(f"Error parsing options in {text!r}")
        options = dict(self._group(word_iter))
        return options
        
    def _group(self, word_iter: Iterator[str]) -> Iterator[tuple[str, list[str]]]:
        option: str | None
        value: list[str]
        final: list[str]
        option, value, final = None, [], []
        for word in word_iter:
            if word == '--':
                if option:
                    yield option, value
                try:
                    final = [next(word_iter)] 
                except StopIteration:
                    final = []  # Special case of '--' at the end.
                break
            elif word.startswith('-'):
                if word in self.args:
                    if option: 
                        yield option, value
                    option, value = word, []
                else:
                    raise ParseError(f"Unknown option {word!r}")
            else:
                if option:
                    if self.args[option].nargs == len(value):
                        yield option, value
                        final = [word]
                        break
                    else:                
                        value.append(word)
                else:
                    final = [word]
                    break
        # In principle, we step through the trailers based on nargs counts.
        for word in word_iter:
            final.append(word)
        yield self.trailers[0], final



class WebReader:
    """Parse an input file, creating Chunks and Commands."""

    output_option_parser = OptionParser(
        OptionDef("-start", nargs=1, default=None),
        OptionDef("-end", nargs=1, default=""),
        OptionDef("argument", nargs='*'),
    )

    # TODO: Allow a numeric argument value in ``-indent``
    definition_option_parser = OptionParser(
        OptionDef("-indent", nargs=0),
        OptionDef("-noindent", nargs=0),
        OptionDef("argument", nargs='*'),
    )
    
    # Configuration
    command: str
    permitList: list[str]
    base_path: Path
    
    # State of the reader
    filePath: Path  #: Input Path 
    _source: TextIO  #: Input file
    tokenizer: Tokenizer  #: The tokenizer used to find commands
    content: list[Chunk]  #: The sequence of Chunk instances being built
    text_command: type[HasText]

    def __init__(self, parent: Optional["WebReader"] = None) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)

        # Configuration comes from the parent or defaults if there is no parent.
        self.parent = parent
        if self.parent: 
            self.command = self.parent.command
            self.permitList = self.parent.permitList
        else: # Defaults until overridden
            self.command = '@'
            self.permitList = []
                    
        # Summary
        self.totalLines = 0
        self.totalFiles = 0
        self.errors = 0 
        
                
        # Structural ("major") commands
        self.cmdo = self.command+'o'
        self.cmdd = self.command+'d'
        self.cmdlcurl = self.command+'{'
        self.cmdrcurl = self.command+'}'
        self.cmdlbrak = self.command+'['
        self.cmdrbrak = self.command+']'
        self.cmdi = self.command+'i'
        
        # Inline ("minor") commands
        self.cmdlangl = self.command+'<'
        self.cmdrangl = self.command+'>'
        self.cmdpipe = self.command+'|'
        self.cmdlexpr = self.command+'('
        self.cmdrexpr = self.command+')'
        self.cmdcmd = self.command+self.command
        
        # Content "minor" commands
        self.cmdf = self.command+'f'
        self.cmdm = self.command+'m'
        self.cmdu = self.command+'u'

        
    def __str__(self) -> str:
        return self.__class__.__name__
        
        
    def location(self) -> tuple[str, int]:
        return (str(self.filePath), self.tokenizer.lineNumber+1)
    

    
        
    def load(self, filepath: Path, source: TextIO | None = None) -> list[Chunk]:
        """Returns a flat list of chunks to be made into a Web. 
        Also used to expand ``@i`` included files.
        """
        self.filePath = filepath
        self.base_path = self.filePath.parent
        self.text_command = TextCommand
    
        if source:
            self._source = source
            self.parse_source()
        else:
            with self.filePath.open() as self._source:
                self.parse_source()
        return self.content
    
    def parse_source(self) -> None:
        """Builds a sequence of Chunks."""
        self.tokenizer = Tokenizer(self._source, self.command)
        self.totalFiles += 1
    
        # Initial anonymous chunk.
        self.content = [Chunk()]
    
        for token in self.tokenizer:
            if len(token) >= 2 and token.startswith(self.command):
                if self.handleCommand(token):
                    continue
                else:
                    self.logger.error('Unknown @-command in input: %r near %r', token, self.location())
                    cls = self.text_command
                    self.content[-1].commands.append(cls(token, self.location()))
                    
            elif token:
                # Accumulate a non-empty block of text in the current chunk.
                # Output Chunk and Named Chunk should have CodeCommand 
                # Chunk should have TextCommand.
                # Edge case is Chunk with no Command
                if len(self.content[-1].commands) == 0:
                    cls = self.text_command
                    self.content[-1].commands.append(cls(token, self.location()))
                elif (tail := self.content[-1].commands[-1]) and (tail.typeid.CodeCommand or tail.typeid.TextCommand):
                    cast(HasText, tail).text += token
                else:
                    # A non-text command: one of @< name @>, @f, @m, @u.
                    cls = self.text_command
                    self.content[-1].commands.append(cls(token, self.location()))
                
            else:
                # Whitespace
                pass
        self.logger.debug("parse_source: [")
        for c in self.content:
            self.logger.debug("  %r", c)
        self.logger.debug("]")
    

    
        
    def handleCommand(self, token: str) -> bool:
        self.logger.debug("Reading %r", token)
        new_chunk: Optional[Chunk] = None
        match token[:2]:
            case self.cmdo:
                                
                args = next(self.tokenizer)
                self.expect({self.cmdlcurl})
                options = self.output_option_parser.parse(args)
                new_chunk = OutputChunk(
                    name=' '.join(options['argument']),
                    comment_start=''.join(options.get('start', "# ")),
                    comment_end=''.join(options.get('end', "")),
                )
                self.content.append(new_chunk)
                self.text_command = CodeCommand
                # capture an OutputChunk up to @}
    
            case self.cmdd:
                                
                args = next(self.tokenizer)
                brack = self.expect({self.cmdlcurl, self.cmdlbrak})
                options = self.output_option_parser.parse(args)
                name = ' '.join(options['argument'])
                
                if brack == self.cmdlbrak:
                    new_chunk = NamedDocumentChunk(name)
                elif brack == self.cmdlcurl:
                    if '-noindent' in options:
                        new_chunk = NamedChunk_Noindent(name)
                    else:
                        new_chunk = NamedChunk(name)
                elif brack == None:
                    new_chunk = None
                    pass  # Error already noted by ``expect()``
                else:
                    raise RuntimeError("Design Error")
                
                if new_chunk:
                    self.content.append(new_chunk)
                self.text_command = CodeCommand
                # capture a NamedChunk up to @} or @]
    
            case self.cmdi:
                                
                incPath = Path(next(self.tokenizer).strip())
                try:
                    include = WebReader(parent=self)
                    if not incPath.is_absolute():
                        incPath = self.base_path / incPath
                    self.logger.info("Including '%s'", incPath)
                    self.content.extend(include.load(incPath))
                    self.totalLines += include.tokenizer.lineNumber
                    self.totalFiles += include.totalFiles
                    if include.errors:
                        self.errors += include.errors
                        self.logger.error("Errors in included file '%s', output is incomplete.", incPath)
                except Error as e:
                    self.logger.error("Problems with included file '%s', output is incomplete.", incPath)
                    self.errors += 1
                except IOError as e:
                    self.logger.error("Problems finding included file '%s', output is incomplete.", incPath)
                    # Discretionary -- sometimes we want to continue
                    if self.cmdi in self.permitList: pass
                    else: raise  # Seems heavy-handed, but, the file wasn't found!
                # Start a new context for text or commands *after* the ``@i``.
                self.content.append(Chunk())
    
            case self.cmdrcurl | self.cmdrbrak:
                                
                # Start a new context for text or commands *after* this command.
                self.content.append(Chunk())
                self.text_command = TextCommand
    
            case self.cmdpipe:
                                
                try:
                    names = next(self.tokenizer).strip().split()
                    self.content[-1].def_names.extend(names)
                except AttributeError:
                    # Out of place @| user identifier command
                    self.logger.error("Unexpected references near %r: %r", self.location(), token)
                    self.errors += 1
    
            case self.cmdf:
                self.content[-1].commands.append(FileXrefCommand(self.location()))
            case self.cmdm:
                self.content[-1].commands.append(MacroXrefCommand(self.location()))
            case self.cmdu:
                self.content[-1].commands.append(UserIdXrefCommand(self.location()))
            case self.cmdlangl:
                                
                # get the name, introduce into the named Chunk dictionary
                name = next(self.tokenizer).strip()
                closing = self.expect({self.cmdrangl})
                self.content[-1].commands.append(ReferenceCommand(name, self.location()))
                self.logger.debug("Reading %r %r", name, closing)
    
            case self.cmdlexpr:
                                
                # get the Python expression, create the expression result
                expression = next(self.tokenizer)
                self.expect({self.cmdrexpr})
                try:
                    # Build Context
                    # **TODO:** Parts of this are static and can be built as part of ``__init__()``.
                    dangerous = {
                        'breakpoint', 'compile', 'eval', 'exec', 'execfile', 'globals', 'help', 'input', 
                        'memoryview', 'open', 'print', 'super', '__import__'
                    }
                    safe = types.SimpleNamespace(**dict(
                        (name, obj) 
                        for name,obj in builtins.__dict__.items() 
                        if name not in dangerous
                    ))
                    globals = dict(
                        __builtins__=safe, 
                        os=types.SimpleNamespace(path=os.path, getcwd=os.getcwd, name=os.name),
                        time=time,
                        datetime=datetime,
                        platform=platform,
                        theWebReader=self,
                        theFile=self.filePath,
                        thisApplication=sys.argv[0],
                        __version__=__version__,  # Legacy compatibility. Deprecated.
                        version=__version__,
                        theLocation=str(self.location()),  # The only thing that's dynamic
                        )
                    # Evaluate
                    result = str(eval(expression, globals))
                except Exception as exc:
                    self.logger.error('Failure to process %r: exception is %r', expression, exc)
                    self.errors += 1
                    result = f"@({expression!r}: Error {exc!r}@)"
                cls = self.text_command
                self.content[-1].commands.append(cls(result, self.location()))
    
            case self.cmdcmd:
                                
                self.logger.debug(f"double-command: {self.content[-1]=}")
                cls = self.text_command
                if len(self.content[-1].commands) == 0:  
                    self.content[-1].commands.append(cls(self.command, self.location()))
                else:
                    tail = self.content[-1].commands[-1]
                    if tail.typeid.CodeCommand or tail.typeid.TextCommand:
                        cast(HasText, tail).text += self.command
                    else:
                        # A non-text command: one of @< name @>, @f, @m, @u.
                        self.content[-1].commands.append(cls(self.command, self.location()))
    
            case self.cmdlcurl | self.cmdlbrak:
                # These should have been consumed as part of @o and @d parsing
                self.logger.error("Extra %r (possibly missing chunk name) near %r", token, self.location())
                self.errors += 1
            case _:
                return False  # did not recogize the command
        return True  # did recognize the command
    
    
    def expect(self, tokens: set[str]) -> str | None:
        """Compare next token with expectation, quietly skipping whitespace (i.e., ``\n``)."""
        try:
            t = next(self.tokenizer)
            while t == '\n':
                t = next(self.tokenizer)
        except StopIteration:
            self.logger.error("At %r: end of input, %r not found", self.location(), tokens)
            self.errors += 1
            return None
        if t in tokens:
            return t
        else:
            self.logger.error("At %r: expected %r, found %r", self.location(), tokens, t)
            self.errors += 1
            return None
    





class Action:
    """An action performed by pyWeb."""
    start: float
    options: argparse.Namespace

    def __init__(self, name: str) -> None:
        self.name = name
        self.logger = logging.getLogger(self.__class__.__qualname__)

    def __str__(self) -> str:
        return f"{self.name!s} [{self.options.web!s}]"
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        self.logger.info("Starting %s", self.name)
        self.options = options
        self.start = time.process_time()
    

    
        
    def duration(self) -> float:
        """Return duration of the action."""
        return (self.start and time.process_time()-self.start) or 0
        
    def summary(self) -> str:
        return f"{self.name!s} in {self.duration():0.3f} sec."
    




class ActionSequence(Action):
    """An action composed of a sequence of other actions."""
    def __init__(self, name: str, opSequence: list[Action] | None = None) -> None:
        super().__init__(name)
        if opSequence: self.opSequence = opSequence
        else: self.opSequence = []
        
    def __str__(self) -> str:
        return "; ".join([str(x) for x in self.opSequence])
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        for o in self.opSequence:
            o(self.options)
    

        
        
    def summary(self) -> str:
        return ", ".join([o.summary() for o in self.opSequence])
    




class WeaveAction(Action):
    """Weave the final document."""
    def __init__(self) -> None:
        super().__init__("Weave")
        
    def __str__(self) -> str:
        return f"{self.name!s} [{self.options.web!s}, {self.options.theWeaver!s}]"

        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        if not self.options.weaver: 
            # Examine first few chars of first chunk of web to determine language
            self.options.weaver = self.options.web.language() 
            self.logger.info("Using %s", self.options.theWeaver)
        self.options.theWeaver.reference_style = self.options.reference_style
        self.options.theWeaver.output = self.options.output
        try:
            self.options.theWeaver.set_markup(self.options.weaver)
            self.options.theWeaver.emit(self.options.web)
            self.logger.info("Finished Normally")
        except Error as e:
            self.logger.error("Problems weaving document from %r (weave file is faulty).", self.options.web.web_path)
            #raise
    

    
        
    def summary(self) -> str:
        if self.options.theWeaver and self.options.theWeaver.linesWritten > 0:
            return (
                f"{self.name!s} {self.options.theWeaver.linesWritten:d} lines in {self.duration():0.3f} sec."
            )
        return f"did not {self.name!s}"
    




class TangleAction(Action):
    """Tangle source files."""
    def __init__(self) -> None:
        super().__init__("Tangle")
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        self.options.theTangler.include_line_numbers = self.options.tangler_line_numbers
        self.options.theTangler.output = self.options.output
        try:
            self.options.theTangler.emit(self.options.web)
        except Error as e:
            self.logger.error("Problems tangling outputs from %r (tangle files are faulty).", self.options.web.web_path)
            #raise
    

    
        
    def summary(self) -> str:
        if self.options.theTangler and self.options.theTangler.linesWritten > 0:
            return (
                f"{self.name!s} {self.options.theTangler.totalLines:d} lines in {self.duration():0.3f} sec."
            )
        return f"did not {self.name!r}"
    




class LoadAction(Action):
    """Load the source web."""
    def __init__(self) -> None:
        super().__init__("Load")
        
    def __str__(self) -> str:
        return f"Load [{self.webReader!s}, {self.options.web!s}]"
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        self.webReader = self.options.webReader
        self.webReader.command = self.options.command
        self.webReader.permitList = self.options.permitList
        self.logger.debug("Reader Class %s", self.webReader.__class__.__name__)
    
        error = f"Problems with source file {self.options.source_path!r}, no output produced."
        try:
            chunks = self.webReader.load(self.options.source_path)
            if self.webReader.errors != 0:
                raise Error("Syntax Errors in the Web")
            self.logger.debug("Read %d Chunks", len(chunks))
            self.options.web = Web(chunks)
            self.options.web.web_path = self.options.source_path
            self.logger.debug("Web contains %3d chunks", len(self.options.web.chunks))
            self.logger.debug("Web defines  %3d files", len(self.options.web.files))
            self.logger.debug("Web defines  %3d macros", len(self.options.web.macros))
            self.logger.debug("Web defines  %3d names", len(self.options.web.userids))
        except Error as e:
            self.logger.error(error)
            raise  # Could not be parsed or built.
        except IOError as e:
            self.logger.error(error)
            raise
    

    
        
    def summary(self) -> str:
        return (
            f"{self.name!s} {self.webReader.totalLines:d} lines from {self.webReader.totalFiles:d} files in {self.duration():0.3f} sec."
        )
    





class Application:
    def __init__(self) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)
                
        self.defaults = argparse.Namespace(
            verbosity=logging.INFO,
            command='@',
            weaver='rst', 
            skip='',  # Don't skip any steps
            permit='',  # Don't tolerate missing includes
            reference='s',  # Simple references
            tangler_line_numbers=False,
            output=Path.cwd(),
            )
        
        # Primitive Actions
        self.loadOp = LoadAction()
        self.weaveOp = WeaveAction()
        self.tangleOp = TangleAction()
        
        # Composite Actions
        self.doWeave = ActionSequence("load and weave", [self.loadOp, self.weaveOp])
        self.doTangle = ActionSequence("load and tangle", [self.loadOp, self.tangleOp])
        self.theAction = ActionSequence("load, tangle and weave", [self.loadOp, self.tangleOp, self.weaveOp])

        
        
    def parseArgs(self, argv: list[str]) -> argparse.Namespace:
        p = argparse.ArgumentParser()
        p.add_argument("-v", "--verbose", dest="verbosity", action="store_const", const=logging.INFO)
        p.add_argument("-s", "--silent", dest="verbosity", action="store_const", const=logging.WARN)
        p.add_argument("-d", "--debug", dest="verbosity", action="store_const", const=logging.DEBUG)
        p.add_argument("-c", "--command", dest="command", action="store")
        p.add_argument("-w", "--weaver", dest="weaver", action="store")
        p.add_argument("-x", "--except", dest="skip", action="store", choices=('w', 't'))
        p.add_argument("-p", "--permit", dest="permit", action="store")
        p.add_argument("-r", "--reference", dest="reference", action="store", choices=('t', 's'))
        p.add_argument("-n", "--linenumbers", dest="tangler_line_numbers", action="store_true")
        p.add_argument("-o", "--output", dest="output", action="store", type=Path)
        p.add_argument("-V", "--Version", action='version', version=f"py-web-tool pyweb.py {__version__}")
        p.add_argument("files", nargs='+', type=Path)
        config = p.parse_args(argv, namespace=self.defaults)
        self.expand(config)
        return config
        
    def expand(self, config: argparse.Namespace) -> argparse.Namespace:
        """Translate the argument values from simple text to useful objects.
        Weaver. Tangler. WebReader.
        """
        match config.reference:
            case 't':
                config.reference_style = TransitiveReference() 
            case 's':
                config.reference_style = SimpleReference()
            case _:
                raise Error("Improper configuration")
    
        # Weaver & Tangler
        config.theWeaver = Weaver(config.output)
        config.theTangler = TanglerMake(config.output)
        
        if config.permit:
            # save permitted errors, usual case is ``-pi`` to permit ``@i`` include errors
            config.permitList = [f'{config.command!s}{c!s}' for c in config.permit]
        else:
            config.permitList = []
    
        config.webReader = WebReader()
    
        return config
    

    
        
    def process(self, config: argparse.Namespace) -> None:
        root = logging.getLogger()
        root.setLevel(config.verbosity)
        self.logger.debug("Setting root log level to %r", logging.getLevelName(root.getEffectiveLevel()))
        
        if config.command:
            self.logger.debug("Command character %r", config.command)
            
        if config.skip:
            if config.skip.lower().startswith('w'):  # not weaving == tangling
                self.theAction = self.doTangle
            elif config.skip.lower().startswith('t'):  # not tangling == weaving
                self.theAction = self.doWeave
            else:
                raise Exception(f"Unknown -x option {config.skip!r}")
    
        for f in config.files:
            self.logger.info("%s %s %r", self.theAction.name, __version__, f)
            config.source_path = f
            self.theAction(config)
            self.logger.info(self.theAction.summary())
    




class Logger:
    def __init__(self, dict_config: dict[str, Any] | None = None, **kw_config: Any) -> None:
        self.dict_config = dict_config
        self.kw_config = kw_config
        
    def __enter__(self) -> "Logger":
        if self.dict_config:
            logging.config.dictConfig(self.dict_config)
        else:
            logging.basicConfig(**self.kw_config)
        return self
        
    def __exit__(self, *args: Any) -> Literal[False]:
        logging.shutdown()
        return False

log_config = {
    'version': 1,
    'disable_existing_loggers': False, # Allow pre-existing loggers to work.
    'style': '{',
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'stream': 'ext://sys.stderr',
            'formatter': 'basic',
        },
    },
    'formatters': {
        'basic': {
            'format': "{levelname}:{name}:{message}",
            'style': "{",
        }
    },
    
    'root': {'handlers': ['console'], 'level': logging.INFO,},
    
    # For specific debugging support...
    'loggers': {
        'Weaver': {'level': logging.INFO},
        'WebReader': {'level': logging.INFO},
        'Tangler': {'level': logging.INFO},
        'TanglerMake': {'level': logging.INFO},
        'indent.TanglerMake': {'level': logging.INFO},
        'Web': {'level': logging.INFO},
        'WebReader': {'level': logging.INFO},
        # Unit test requires this...
        'ReferenceCommand': {'level': logging.INFO},
    },
}


def main(argv: list[str] = sys.argv[1:]) -> None:
    a = Application()
    config = a.parseArgs(argv)
    a.process(config)


if __name__ == "__main__":
    with Logger(log_config):
        main()
